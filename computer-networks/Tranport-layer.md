# Transport layer

## 概述

- 运输层为运行在不同主机上的应用进程之间提供了逻辑通信
- 运输层协议在端系统中实现
- 即使在底层网络协议不可靠的情况下，运输协议也能够为应用程序提供可靠的数据传输服务
- IP称为不可靠服务(unreliable service)，不保证报文段的交付，不保证报文段的按序交付

## 多路复用与多路分解(multiplexing and demultiplexing)

- 多路分解：将运输层报文段终端数据交付到正确的套接字
- 多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层

## UDP

- DNS使用UDP
- UDP的一些优势
  - 关于发送数据以及合适发送的控制更加精细
  - 无需连接建立
  - 无连接状态
  - 分组首部
  - 分组首部开销小

### UDP报文段结构

- {源端口号，目的端口号，长度，检验和，应用数据(报文)}
- UDP检验和：再端到端基础上再运输层提供差错检测功能

## 可靠数据传输原理

- RDT 3.0(比特交替协议)
  - ACK,，超时，冗余检测
  - stop-and-wait：发送方再确认接收方正确接收当前分组之前不会发送下一个分组
  - go-back-N：定义滑动窗口，维护最早未确认分组的序号和最小的未使用序号，一旦有分组被确认，窗口向后滑动，发送新进入的分组(如果有)，使用累积确认，收到ACK代表以前的所有分组都成功接收。接收方丢弃所有失序分组，发送方重传从未正确接收的分组开始的窗口内所有分组。
  - selective repeat：与GBN相比，不使用累积确认，对每一个分组发送单独的ACK接收方缓存失序的分组直到所有丢失的分组被正确接收为止，发送方将已确认的分组标记为已接收，如果成功接收的分组的序号等于基序号，向前滑动窗口

## TCP

### TCP连接

- TCP是面向连接的(connection-oriented)，再一个进程向另一个进程发送数据之前，两个进程必须先进行"握手"，相互发送某些预备报文段，以建立确保数据传输的参数
- TCP提供全双工连接(full-duplex service)，有着TCP连接的书主机之间数据可以双向传递
- TCP连接是点对点的，两个主机构成一对，不能有一个发送发将数据传送给多个接收方
- 发起连接的进程称为客户进程，另一个进程称为服务器进程
- TCP连接的著称包括一堆主机上的缓存、变量和与进程连接的套接字
- 最大报文段长度(Maximum Segment Size, MSS)：从缓存中取出放入报文的数据数量
- 最大链路层帧长度(Maxumum Transmission Unit, MTU)

### TCP连接管理

- 三次握手
  - 客户端向服务器端发送特殊的SYN置为1的报文段，不包含应用层数据，称为SYN报文段；随机选择一个初始序号放入序号字段中
  - 服务器收到SYN报文段，为TCP连接分配TCP缓存和变量，向客户端发送允许连接的报文段，不包含应用层数据，称为SYNACK报文段；SYN比特置为1，确认号字段为收到的初始序号加一，选择自己的初始喜好放入序号字段中
  - 客户端收到SYNACK报文段后，为该连接分配TCP内存和变量，向服务器段发送允许连接的报文段，SYN比特置为0，可以包含发送到服务器段的数据
- 关闭TCP连接：客户端发送关闭连接的报文段，FIN置为1，服务器端收到后发送确认报文段，之后发送自己的FIN比特置为1的终止报文段，客户端收到后发发送确认报文段

### TCP报文段结构

- 源端口号和目的端口号：用于多路复用/分解
- 检验和
- 序号和确认号
  - 序号是该报文段首部的字节流编号
  - 确认号是期望收到的下一字节的序号
  - TCP提供累积确认
- 接收窗口字段：用于流量控制，指示接收方愿意接收的字节数量
- 首部长度字段：指示TCP首部长度
- 选项字段
- 标志字段
  - ACK比特用于指示确认字段中的值是有效的，即该报文段包含一个对已经被成功接收报文段的确认
  - RST, SYN, FIN比特用于连接建立和拆除
  - PSH比特用于指示接收方将数据交付给上层
  - URG比特指示报文段存在被发送端上层置为紧急的数据

### 往返时间的估计与超时

- 报文段的SampleRTT表示从偶报文段被发出到对该报文段确认被收到之间的时间量
- 某一时刻仅做一次SampleRTT的测量，不为重传的数据包做测量
- EstimateRTT是SampleRTT的加权平均，对最近的样本赋予的权值大于旧的样本
- DevRTT估算SampleRTT一般偏离EstimateRTT的程度
- 超时间隔设置为TimeoutInterval = EstimateRTT + 4 * DevRTT

### TCP可靠数据传输

- 采用累积确认
- 在超时发生时，TCP重传具有最小序号的为确认数据段，重启定时器，每次重传时将下一次的超时间隔设置为先前值的两倍
- 在其他情况下启动定时器时，超时间隔设置为计算得出的TimeoutInterval的值(TimeoutInterval = EstimateRTT + 4 * DevRTT)
- 快速重传：收到对相同数据的三个冗余ACK，在该报文段的定时器丢失之前重传丢失的报文段

### TCP流量控制(flow-control service)

- 使发送方的发送速率和接收方的接收速率相匹配，避免发送方使接收方缓存溢出
- 发送方维护接收窗口(receive window)，指示接收方还有多少可用的缓存空间，接收窗口rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)
- 接收方跟踪LastByteSent和LastByteAcked，保证LastByteSent - LastByteAcked小于等于rwnd
- 当主机B的接收窗口为0时，主机A发送只有一个字节数据的报文段，直到确认报文包含非0的rwnd值

### 拥塞控制

- 原因：太多的源想要以过高的速率发送数据
- 代价
  - 当分组的到达速率接近链路容量时，分组经历巨大的排队时延
  - 发送方在遇到大时延时进行的不必要重传会引起路由器利用链路带宽转发不必要的分组副本
  - 当一个分组沿一条路径被丢弃时，每个上游路由器由于转发该分组到丢弃该分组而使用的传输容量最终被浪费
- 端到端拥塞控制：网络层没有为运输层拥塞控制提供显式的支持
- 网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显式反馈信息

### TCP拥塞控制

- 让每个发送方根据所感知到的网络拥塞程度限制其能够向连接发送流量的速率
- 发送方的拥塞控制机制跟踪拥塞窗口cwnd，在一个发送方中未被确认的数据量不会超过cwnd与rwnd的最小值
- 对于一个丢包和发送时延可以忽略不记的连接，发送方的发送速率大概为cwnd/RTT字节/秒
- 指导性原则
  - 一个丢失的报文段意味着拥塞
  - 一个确认报文段指示该网络正在向接收方交付发送方的报文段。因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率
  - 带宽探测：增加传输速率，从该速率后退，进而再次开始探测
- TCP拥塞控制算法
  - 慢启动：cwnd的值以一个MSS的值开始，每当传输的报文段首次被确认就增加1个MSS，这一过程每过一个RTT，cwnd就会翻倍，因此，TCP的发送速率在慢启动阶段将会指数增长当存在一个有超时指示的丢包事件(即拥塞)时，将cwnd值设置为1并重新开始慢启动过程，并将ssthresh的值设置为拥塞窗口值的一半；当cwnd到达或超过ssthresh的值时，进入拥塞避免模式
  - 拥塞避免：每个RTT将cwnd的值增加一个MSS；当收到三个冗余ACK指示发生丢包，将cwnd的值减半，将ssthresh的值记录为cwnd的一半，进入快速恢复状态
  - 快速恢复：对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个ACK，cwnd的值增加一个MSS，最终，当对丢失报文段的最后一个ACK到达时，进入拥塞避免状态
